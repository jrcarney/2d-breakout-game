<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8" />
	<title>Christmas Breakout</title>
	<style>
		
		html {
			background-image: url(snowman.jpg);
			background-size: cover;
			width: 100%;
			height: 100%;
			background-repeat: no-repeat;
		}

		* {
			padding: 0;
			margin: 0;
		}

		#myCanvas {
			background: #eee;

			background-image: url("snowman.jpg");
			background-size: 550px; 
			
			display: block;
			margin: 0 auto;
		}
	</style>
</head>

<body style="height: 100%">
	
	<canvas id="myCanvas" width="480" height="320"></canvas>
	<div id="gameOverContainer" style="position: absolute; bottom: 0;">
		<p id="gameOver"></p>
		<button id="restartGame"></button>
		<div id="scoreContainer">
			<p id="scoreText">Score: </p>
			<p id="score">0</p>
		</div>
	</div>
	<div class="snowContainer" style="width: 100%; height: 80%;"></div>

	<script src="snowfall.js"></script>

	<script>
		(function() {

			/********************************************************/
			// # SETUP OUR CANVAS AND PROPERTIES
			/********************************************************/

			// Store reference to the canvas element
			var canvas = document.getElementById("myCanvas");

			// Store reference to 2D rendering context
			// - the tool we can use for painting to the Canvas
			var ctx = canvas.getContext("2d");

			// Initial ball position: Define the ball postion on the canvas
			var x = canvas.width / 2;
			var y = canvas.height - 30;

			// New ball position: Increases the amount of dx and dy increases the speed of the ball
			var dx = 2;
			var dy = -2;

			var ballRadius = 10;

			// Initialise the paddle
			var paddleHeight = 10;
			var paddleWidth = 75;
			var paddleX = (canvas.width - paddleWidth) / 2;

			// Buttons
			var rightPressed = false;
			var leftPressed = false;

			/* @JC 11/1/18: building some bricks */
			// Bricks: Initialise the amount and shape and padding
			var brickRowCount = 3;
			var brickColumnCount = 5;
			var brickWidth = 75;
			var brickHeight = 20;
			var brickPadding = 10;
			var brickOffsetTop = 30;
			var brickOffsetLeft = 30;

			// Bricks - 2D array: Each bricks array element Contains an object
			// containing the x and y position to paint each brick on the screen.
			var bricks = [];
			for (c = 0; c < brickColumnCount; c++) {
				bricks[c] = [];
				for (r = 0; r < brickRowCount; r++) {
					bricks[c][r] = {
						x: 0,
						y: 0,
						status: 1
					};
				}
			}

			var score = 0;
			var bricksDestroyedCount = 0;
			var gameWon = false;

			/********************************************************/
			// # THE DRAW LOOP
			/********************************************************/

			/**
			 * Every time we draw the ball, draw it at a new position
			 */
			var drawBall = function() {
				ctx.beginPath();
				ctx.arc(x, y, ballRadius, 0, Math.PI * 2, false);
				ctx.fill();
				ctx.closePath();
			};

			/**
			 * Draw the paddle in a different place on screen based on left
			 * right cursor presses
			 */
			var drawPaddle = function() {
				ctx.beginPath();
				ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
				ctx.fillStyle = "#0095DD";
				ctx.fill();
				ctx.closePath();
			};

			// Generate a random colour
			// see: http://stackoverflow.com/questions/1484506/random-color-generator-in-javascript
			var getRandomColor = function() {
				var letters = '0123456789ABCDEF';
				var color = '#';
				for (var i = 0; i < 6; i++) {
					color += letters[Math.floor(Math.random() * 16)];
				}
				return color;
			};

			/**
			 * @function drawBricks
			 *
			 * - Paints columns and rows of bricks to the canvas.
			 * - Destroyed bricks no longer render.
			 */
			var drawBricks = function() {
				for (c = 0; c < brickColumnCount; c++) {
					for (r = 0; r < brickRowCount; r++) {
						if (bricks[c][r].status == 1) {
							var brickX = (c * (brickWidth + brickPadding)) + brickOffsetLeft;
							var brickY = (r * (brickHeight + brickPadding)) + brickOffsetTop;
							bricks[c][r].x = brickX;
							bricks[c][r].y = brickY;
							ctx.beginPath();
							ctx.rect(brickX, brickY, brickWidth, brickHeight);
							ctx.fillStyle = "darkred";
							ctx.fill();
							ctx.closePath();
						}
					}
				}
			};

			/**
			 * @function collisionDetection
			 *
			 * - Sets the status of a brick to zero if the ball hits it.
			 */
			var collisionDetection = function() {
				for (c = 0; c < brickColumnCount; c++) {
					for (r = 0; r < brickRowCount; r++) {
						var b = bricks[c][r];

						// Check for bricks that still exist
						if (b.status == 1) {
							if (x > b.x && x < b.x + brickWidth && y > b.y && y < b.y + brickHeight) {
								dy = -dy;

								// Will force the destroyed brick to no longer render
								b.status = 0;
								bricksDestroyedCount++;
								drawScore();
								isGameComplete();
							}
						}
					}
				}
			}

			/**
			 * @function isGameComplete
			 *
			 * - If all the blocks are destroyed, the player has won the game!
			 */
			var isGameComplete = function() {
				if(bricksDestroyedCount == 15) {
					gameWon = true;
					gameIsOver();
				}
			};

			/**
			 * @function drawScore
			 *
			 * Update the score every time a block has been destroyed
			 */
			 var drawScore = function() {
				 document.querySelector('#score').textContent = score += 10;
			 };

 			/**
			 * @function moveBallUpward
			 *
 			 * The ball hits the paddle: The ball travels upward and the game
 			 * continues...
 			 */
 			var moveBallUpward = function(dy) {
 				dy = -dy;
 				return dy;
 			};

			/**
			 * @function moveBallHorizontally
			 *
			 * The ball hits the paddle: The ball travels upward and the game
			 * continues...
			 */
			var moveBallHorizontally = function(dx) {
				dx = -dx;
				return dx;
			};

			/**
			 * @function gameIsOver
			 *
			 * Stop the draw loop and display a 'you won' or 'game over message'
			 */
			var gameIsOver = function() {

				// Stop calling the draw() game loop when the ball has dissapeared
				// below the bottom of the canvas
				setTimeout(function() {
					clearInterval(interval);
				}, 500);

				// Display some Game over text
				if(gameWon) {
					document.querySelector('#gameOver').textContent = "YOU WIN!!";

				} else {
					document.querySelector('#gameOver').textContent = "GAME OVER";

				}

				document.querySelector('#restartGame').textContent = "RESTART GAME";

				// Prevent the player from moving the paddles when its Game Over
				document.removeEventListener("keydown", keyDownHandler, false);
				document.removeEventListener("keyup", keyUpHandler, false);
			};

			/**
			 * @function draw
			 *
			 * - Every 10 milliseconds, clear the canvas, re-draw the bricks and ball.
			 * - The ball is redrawn in a new postion.
			 * - The paddle is redrawn in a new position based on left right button presses
			 * - Allows the ball to dissapear below the canvas, ending the game.
			 */
			var draw = function() {

				// Clear the canvas and re-draw everything
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				drawBricks();
				drawBall();
				drawPaddle();
				collisionDetection();

				x += dx;
				y += dy;

				/********************************************************/
				// # COLLISION DETECTION
				/********************************************************/

				// If the ball is right edge or less than the left edge,
				// reverse the movement of the ball
				if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) {
					dx = moveBallHorizontally(dx);

					// Every time the ball hits a wall, change the ball colour
					ctx.fillStyle = getRandomColor();
				}

				// 0 is the top edge canvas.height is the bottom edge
				// If the ball is above the top edge reverse the movement of the ball
				if (y + dy < ballRadius) {
					dy = moveBallUpward(dy);

					// Every time the ball hits a wall, change the ball colour
					ctx.fillStyle = getRandomColor();

				} else if (y + dy > canvas.height - ballRadius) {

					if (x > paddleX && x < paddleX + paddleWidth) {
						dy = moveBallUpward(dy);

					} else {
						gameIsOver();

					}
				}
				/// End collision detection

				/**
				 * Move the paddle on the left or right side of the canvas based
				 * on whether the left or right buttons were pressed.
				 */
				if (rightPressed && paddleX < canvas.width - paddleWidth) {
					paddleX += 7;

				} else if (leftPressed && paddleX > 0) {
					paddleX -= 7;

				}

				/**
				 * @function logDrawFn
				 *
				 * Logging function: used to output the position of the x and y position
				 * of the ball.
				 */
				function logDrawFn() {
					console.log('y is: ');
					console.log(y);
					console.log('x is: ');
					console.log(x);
				}

				// Framerate controlled by the host environment
				requestAnimationFrame(draw);
			}

			/********************************************************/
			// # ENTER THE DRAW LOOP
			/********************************************************/
			
			// Commented out to use requestAnimationFrame()
			// var interval = setInterval(draw, 10);
			
			// Calls draw which runs requestAnimationFrame(draw);
			draw();

			// End enter the draw loop

			/********************************************************/
			// # EVENTS
			/********************************************************/

			/**
			 * Handle left and right movement of the paddle
			 */
			var keyDownHandler = function(e) {
				if (e.keyCode == 39) {
					//debugger
					rightPressed = true;

				} else if (e.keyCode == 37) {
					//debugger
					leftPressed = true;
				}
			};

			var keyUpHandler = function(e) {
				if (e.keyCode == 39) {
					rightPressed = false;

				} else if (e.keyCode == 37) {
					leftPressed = false;
				}

			};

			document.addEventListener("keydown", keyDownHandler, false);
			document.addEventListener("keyup", keyUpHandler, false);

			/**
			 * Handle restartig of the game
			 */
			var restartGame = function(e) {
				if (e.target.id == 'restartGame') {
					window.location.reload();
				}
			};

			document.addEventListener("click", restartGame, false);

		}());
	</script>

</body>

</html>
