<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8" />
	<title>MDN: 2d breakout game</title>
	<style>
		* {
			padding: 0;
			margin: 0;
		}

		canvas {
			background: #eee;
			display: block;
			margin: 0 auto;
		}
	</style>
</head>

<body>
	<canvas id="myCanvas" width="480" height="320"></canvas>
	<div id="gameOverContainer">
		<p id="gameOver"></p>
		<button id="restartGame"></button>
	</div>

	<script>
		(function() {

			/********************************************************/
			// # SETUP OUR CANVAS AND PROPERTIES
			/********************************************************/

			// Store reference to the canvas element
			var canvas = document.getElementById("myCanvas");

			// Store reference to 2D rendering context
			// - the tool we can use for painting to the Canvas
			var ctx = canvas.getContext("2d");

			// Initial ball position: Define the ball postion on the canvas
			var x = canvas.width / 2;
			var y = canvas.height - 30;

			// New ball position:
			// Define the amount the ball should move across and up the canvas
			// NOTE: Changing dxvalues increase
			var dx = 2;
			var dy = -2;

			var ballRadius = 10;

			// Initialise the paddle
			var paddleHeight = 10;
			var paddleWidth = 75;
			var paddleX = (canvas.width - paddleWidth) / 2;

			// Buttons
			var rightPressed = false;
			var leftPressed = false;

			/* @JC 11/1/18: building some bricks */
			// Bricks: Initialise the amount and shape and padding
			var brickRowCount = 3;
			var brickColumnCount = 5;
			var brickWidth = 75;
			var brickHeight = 20;
			var brickPadding = 10;
			var brickOffsetTop = 30;
			var brickOffsetLeft = 30;

			// Bricks - 2D array: Each bricks array element Contains an object
			// containing the x and y position to paint each brick on the screen.
			var bricks = [];
			for (c = 0; c < brickColumnCount; c++) {
				bricks[c] = [];
				for (r = 0; r < brickRowCount; r++) {
					bricks[c][r] = {
						x: 0,
						y: 0,
						status: 1
					};
				}
			}

			/********************************************************/
			// # THE DRAW LOOP
			/********************************************************/

			/**
			 * Every time we draw the ball, draw it at a new position
			 */
			var drawBall = function() {
				ctx.beginPath();
				ctx.arc(x, y, ballRadius, 0, Math.PI * 2, false);
				ctx.fill();
				ctx.closePath();
			};

			/**
			 * Draw the paddle in a different place on screen based on left
			 * right cursor presses
			 */
			var drawPaddle = function() {
				ctx.beginPath();
				ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
				ctx.fillStyle = "#0095DD";
				ctx.fill();
				ctx.closePath();
			};

			// Generate a random colour
			// see: http://stackoverflow.com/questions/1484506/random-color-generator-in-javascript
			var getRandomColor = function() {
				var letters = '0123456789ABCDEF';
				var color = '#';
				for (var i = 0; i < 6; i++) {
					color += letters[Math.floor(Math.random() * 16)];
				}
				return color;
			};

			/**
			 * @function drawBricks
			 *
			 * - Paints columns and rows of bricks to the canvas.
			 * - Destroyed bricks no longer render.
			 */
			var drawBricks = function() {
				for (c = 0; c < brickColumnCount; c++) {
					for (r = 0; r < brickRowCount; r++) {
						if (bricks[c][r].status == 1) {
							var brickX = (c * (brickWidth + brickPadding)) + brickOffsetLeft;
							var brickY = (r * (brickHeight + brickPadding)) + brickOffsetTop;
							bricks[c][r].x = brickX;
							bricks[c][r].y = brickY;
							ctx.beginPath();
							ctx.rect(brickX, brickY, brickWidth, brickHeight);
							ctx.fillStyle = "#0095DD";
							ctx.fill();
							ctx.closePath();
						}
					}
				}
			};

			/**
			 * @function collisionDetection
			 *
			 * - Sets the status of a brick to zero if the ball hits it.
			 */
			var collisionDetection = function() {
				for (c = 0; c < brickColumnCount; c++) {
					for (r = 0; r < brickRowCount; r++) {
						var b = bricks[c][r];

						// Check for bricks that still exist
						if (b.status == 1) {
							if (x > b.x && x < b.x + brickWidth && y > b.y && y < b.y + brickHeight) {
								dy = -dy;

								// Will force the destroyed brick to no longer render
								b.status = 0;
							}
						}
					}
				}
			}

			/**
			 * @function draw
			 *
			 * - Every 10 milliseconds, clear the canvas, re-draw the bricks and ball.
			 * - The ball is redrawn in a new postion.
			 * - The paddle is redrawn in a new position based on left right button presses
			 * - Allows the ball to dissapear below the canvas, ending the game.
			 */
			var draw = function() {

				// Clear the canvas and re-draw everything
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				drawBricks();
				drawBall();
				drawPaddle();
				collisionDetection();

				x += dx;
				y += dy;

				/********************************************************/
				// # COLLISION DETECTION
				/********************************************************/

				// If the ball is right edge or less than the left edge,
				// reverse the movement of the ball
				if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) {
					moveBallHorizontally();

					// Every time the ball hits a wall, change the ball colour
					ctx.fillStyle = getRandomColor();
				}

				// 0 is the top edge canvas.height is the bottom edge
				// If the ball is above the top edge reverse the movement of the ball
				if (y + dy < ballRadius) {
					moveBallUpward();

					// Every time the ball hits a wall, change the ball colour
					ctx.fillStyle = getRandomColor();

				} else if (y + dy > canvas.height - ballRadius) {

					if (x > paddleX && x < paddleX + paddleWidth) {
						moveBallUpward();

					} else {
						gameIsOver();

					}
				}

				/**
				 * The ball hits the paddle: The ball travels upward and the game
				 * continues...
				 */
				function moveBallUpward() {
					dy = -dy;
				}

				/**
				 * The ball hits the paddle: The ball travels upward and the game
				 * continues...
				 */
				function moveBallHorizontally() {
					dx = -dx;
				}

				/**
				 * Game Over: When the ball dissapears below the canvas its Game Over!
				 */
				function gameIsOver() {

					// Stop calling the draw() game loop when the ball has dissapeared
					// below the bottom of the canvas
					setTimeout(function() {
						clearInterval(interval);
					}, 500);

					// Display some Game over text
					document.querySelector('#gameOver').textContent = "GAME OVER";
					document.querySelector('#restartGame').textContent = "RESTART GAME";

					// Prevent the player from moving the paddles when its Game Over
					document.removeEventListener("keydown", keyDownHandler, false);
					document.removeEventListener("keyup", keyUpHandler, false);
				}

				/// End collision detection

				/**
				 * Move the paddle on the left or right side of the canvas based
				 * on whether the left or right buttons were pressed.
				 */
				if (rightPressed && paddleX < canvas.width - paddleWidth) {
					paddleX += 7;

				} else if (leftPressed && paddleX > 0) {
					paddleX -= 7;

				}

				/**
				 * @function logDrawFn
				 *
				 * Logging function: used to output the position of the x and y position
				 * of the ball.
				 */
				function logDrawFn() {
					console.log('y is: ');
					console.log(y);
					console.log('x is: ');
					console.log(x);
				}

			}

			/********************************************************/
			// # ENTER THE DRAW LOOP
			/********************************************************/
			var interval = setInterval(draw, 10);
			// End enter the draw loop

			/********************************************************/
			// # EVENTS
			/********************************************************/

			/**
			 * Handle left and right movement of the paddle
			 */
			var keyDownHandler = function(e) {
				if (e.keyCode == 39) {
					//debugger
					rightPressed = true;

				} else if (e.keyCode == 37) {
					//debugger
					leftPressed = true;
				}

			};

			var keyUpHandler = function(e) {
				if (e.keyCode == 39) {
					rightPressed = false;

				} else if (e.keyCode == 37) {
					leftPressed = false;
				}

			};

			document.addEventListener("keydown", keyDownHandler, false);
			document.addEventListener("keyup", keyUpHandler, false);

			/**
			 * Handle restartig of the game
			 */
			var restartGame = function(e) {
				if (e.target.id == 'restartGame') {
					window.location.reload();
				}
			};

			document.addEventListener("click", restartGame, false);

		}());
	</script>

</body>

</html>
