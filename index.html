<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8" />
	<title>Christmas Breakout</title>
	<style>
		
		html {
			background-image: url(snowman.jpg);
			background-size: cover;
			width: 100%;
			height: 100%;
			background-repeat: no-repeat;
		}

		* {
			padding: 0;
			margin: 0;
		}

		#myCanvas {
			background: #eee;

			background-image: url("snowman.jpg");
			background-size: 550px; 
			
			display: block;
			margin: 0 auto;
		}

		#nextLevel {
			display: none;
		}

		.snowContainer {
			width: 100%;
			height: 100%;
			position: absolute;
			top: 0;
			z-index: -999;
		}

		#gameOverContainer {
			position: absolute;
			bottom: 0;
			z-index: 999;
		}
	</style>
</head>

<body style="height: 100%">
	
	<canvas id="myCanvas" width="480" height="320"></canvas>
	<div id="gameOverContainer" style="position: absolute; bottom: 0;">
		<h2 id="gameOver"></h2>
		<button id="restartLevel">Restart level</button>
		<button id="nextLevel"></button>
		<button id="newGame">Reset to level one</button>
		<div id="scoreContainer">
			<p id="scoreText">Current Score: </p>
			<p id="score"></p>
		</div>
		<p id="highestScoreText">Highest score:</p>
		<p id="highestScore"></p>
		<p id="currentLevelText">Current level:</p>
		<p id="currentLevel"></p>
	
	</div>
	<div class="snowContainer"></div>

	<script src="snowfall.js"></script>

	<script>
		(function() {

			// debugger

			/********************************************************/
			// # SETUP OUR CANVAS AND PROPERTIES
			/********************************************************/

			// Store reference to the canvas element
			var canvas = document.getElementById("myCanvas");

			// Store reference to 2D rendering context
			// - the tool we can use for painting to the Canvas
			var ctx = canvas.getContext("2d");

			// Initial ball position: Define the ball postion on the canvas
			var x = canvas.width / 2;
			var y = canvas.height - 30;

			// @JC 23/12/18: 
			// New ball position: Increases the amount of dx and dy increases the speed of the ball
			if(localStorage.getItem("dx") ) {
				var dx = parseInt( localStorage.getItem("dx") );
			} else {
				var dx = 3;
			}

			if(localStorage.getItem("dy") ) {
				var dy = parseInt( localStorage.getItem("dy") );
			} else {
				var dy = -3;
			}
			

			var ballRadius = 10;

			// Initialise the paddle
			var paddleHeight = 10;
			var paddleWidth = 75;
			var paddleX = (canvas.width - paddleWidth) / 2;

			// Buttons
			var rightPressed = false;
			var leftPressed = false;

			/* @JC 11/1/18: building some bricks */
			// Bricks: Initialise the amount and shape and padding
			var brickRowCount = 3;
			var brickColumnCount = 5;
			var brickWidth = 75;
			var brickHeight = 20;
			var brickPadding = 10;
			var brickOffsetTop = 30;
			var brickOffsetLeft = 30;

			// Bricks - 2D array: Each bricks array element Contains an object
			// containing the x and y position to paint each brick on the screen.
			var bricks = [];
			for (c = 0; c < brickColumnCount; c++) {
				bricks[c] = [];
				for (r = 0; r < brickRowCount; r++) {
					bricks[c][r] = {
						x: 0,
						y: 0,
						status: 1
					};
				}
			}

			
			if( localStorage.getItem("score") ) {
				var score = parseInt( localStorage.getItem("score") );
			}
			else {
				var score = 0;
			}
			var bricksDestroyedCount = 0;
			var gameWon = false;

			// @23/18/12: Utimately used for stopping the game loop.
			// declaration used for storing the return value of requestAnimationFrame().
			var frames;

			// @23/18/12: declaration used for stopping the animationFrames
			var stop;
			
			// @23/18/12: declaration used for storing the level the player is on.
			if(localStorage.getItem("level") ) {
				var levelNumber = localStorage.getItem("level");
			} else {
				var levelNumber = 1;
			}

			// ############################################################ //
			// @tag: testMode / test mode
			// @JC 23/12/18: set this to true to enter test game mode. only use for testing!!
			// when not testing, set to false
			var overrideCount = false;
			// ############################################################ //

			/********************************************************/
			// # THE DRAW LOOP
			/********************************************************/

			/**
			 * Every time we draw the ball, draw it at a new position
			 */
			var drawBall = function() {
				ctx.beginPath();
				ctx.arc(x, y, ballRadius, 0, Math.PI * 2, false);
				ctx.fill();
				ctx.closePath();
			};

			/**
			 * Draw the paddle in a different place on screen based on left
			 * right cursor presses
			 */
			var drawPaddle = function() {
				ctx.beginPath();
				ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
				ctx.fillStyle = "#0095DD";
				ctx.fill();
				ctx.closePath();
			};

			// Generate a random colour
			// see: http://stackoverflow.com/questions/1484506/random-color-generator-in-javascript
			var getRandomColor = function() {
				var letters = '0123456789ABCDEF';
				var color = '#';
				for (var i = 0; i < 6; i++) {
					color += letters[Math.floor(Math.random() * 16)];
				}
				return color;
			};

			/**
			 * @function drawBricks
			 *
			 * - Paints columns and rows of bricks to the canvas.
			 * - Destroyed bricks no longer render.
			 */
			var drawBricks = function() {
				for (c = 0; c < brickColumnCount; c++) {
					for (r = 0; r < brickRowCount; r++) {
						if (bricks[c][r].status == 1) {
							var brickX = (c * (brickWidth + brickPadding)) + brickOffsetLeft;
							var brickY = (r * (brickHeight + brickPadding)) + brickOffsetTop;
							bricks[c][r].x = brickX;
							bricks[c][r].y = brickY;
							ctx.beginPath();
							ctx.rect(brickX, brickY, brickWidth, brickHeight);
							ctx.fillStyle = "darkred";
							ctx.fill();
							ctx.closePath();
						}
					}
				}
			};

			/**
			 * @function collisionDetection
			 *
			 * - Sets the status of a brick to zero if the ball hits it.
			 */
			var collisionDetection = function() {
				for (c = 0; c < brickColumnCount; c++) {
					for (r = 0; r < brickRowCount; r++) {
						var b = bricks[c][r];

						// Check for bricks that still exist
						if (b.status == 1) {
							if (x > b.x && x < b.x + brickWidth && y > b.y && y < b.y + brickHeight) {
								dy = -dy;

								// Will force the destroyed brick to no longer render
								b.status = 0;
								bricksDestroyedCount++;
								drawScore();
								isGameComplete();
							}
						}
					}
				}
			}

			/**
			 * @function isGameComplete
			 *
			 * - If all the blocks are destroyed, the player has won the game!
			 */
			var isGameComplete = function() {
				if(overrideCount == true) {
					if(bricksDestroyedCount == 1) {
						gameWon = true;
						gameIsOver();						
					}	

				} else {				
					if(bricksDestroyedCount == 15) {
						gameWon = true;
						gameIsOver();
					}	
				}
			};

			/**
			 * @function drawScore
			 *
			 * Update the score every time a block has been destroyed
			 */
			 var drawScore = function() {				 
				score = score +10;

				localStorage.setItem("score", score);
				document.querySelector('#score').textContent = score;
			 };

 			/**
			 * @function moveBallUpward
			 *
 			 * The ball hits the paddle: The ball travels upward and the game
 			 * continues...
 			 */
 			var moveBallUpward = function(dy) {
 				dy = -dy;
 				return dy;
 			};

			/**
			 * @function moveBallHorizontally
			 *
			 * The ball hits the paddle: The ball travels upward and the game
			 * continues...
			 */
			var moveBallHorizontally = function(dx) {
				dx = -dx;
				return dx;
			};

			/**
			 * @function gameIsOver
			 *
			 * Stop the draw loop and display a 'you won' or 'game over message'
			 */
			var gameIsOver = function() {
				// @JC 23/12/18: no longer used as requestAnimatinoFrame() is used.
				// Stop calling the draw() game loop when the ball has dissapeared below the bottom of the canvas
				// setTimeout(function() {
				// 	clearInterval(interval);
				// }, 500);

				scoreCounter();

				// Display some Game over text
				if(gameWon) {
					document.querySelector('#gameOver').textContent = "Level complete";
					
					// @JC 23/12/18: Display the next level button
					document.querySelector('#nextLevel').style.display = "block";
					document.querySelector('#nextLevel').textContent = "Go to next level";

					// @JC 23/12/18: might need to remove
					stop = true;
					stopDrawing(stop);

				} else {
					
					document.querySelector('#gameOver').textContent = "GAME OVER";
					
					// @JC 23/12/18: might need to remove
					stop = true;
					stopDrawing(stop);

					// @JC 23/12/18: commented out so to use the level up system
					// Display restart game button
					document.querySelector('#restartLevel').textContent = "Restart level";
					localStorage.setItem("score", 0);	
					//localStorage.setItem("level", 1);	
				}

				// Prevent the player from moving the paddles when its Game Over
				document.removeEventListener("keydown", keyDownHandler, false);
				document.removeEventListener("keyup", keyUpHandler, false);			
				
	
			};

			// 23/12/18: set the high score
			var scoreCounter = function() {

				if(localStorage.getItem("highScore")){		
					console.log("meh");
					document.querySelector('#highestScore').textContent = localStorage.getItem("highScore");
				} else {
					
					document.querySelector('#highestScore').textContent =  "No high score recorded yet";
					localStorage.setItem("highScore", score);
				}
				

				if( score > parseInt( localStorage.getItem("highScore") )) {
					
					localStorage.setItem("highScore", score);
					document.querySelector('#highestScore').textContent =  parseInt( localStorage.getItem("highScore") );
				}

				
			}
			
	
			/**
			 * @function draw
			 *
			 * - Every 10 milliseconds, clear the canvas, re-draw the bricks and ball.
			 * - The ball is redrawn in a new postion.
			 * - The paddle is redrawn in a new position based on left right button presses
			 * - Allows the ball to dissapear below the canvas, ending the game.
			 */
			var draw = function() {

				

				// Clear the canvas and re-draw everything
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				drawBricks();
				drawBall();
				drawPaddle();
				collisionDetection();

				x += dx;
				y += dy;

				/********************************************************/
				// # COLLISION DETECTION
				/********************************************************/

				// If the ball is right edge or less than the left edge,
				// reverse the movement of the ball
				if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) {
					dx = moveBallHorizontally(dx);

					// Every time the ball hits a wall, change the ball colour
					ctx.fillStyle = getRandomColor();
				}

				// 0 is the top edge canvas.height is the bottom edge
				// If the ball is above the top edge reverse the movement of the ball
				if (y + dy < ballRadius) {
					dy = moveBallUpward(dy);

					// Every time the ball hits a wall, change the ball colour
					ctx.fillStyle = getRandomColor();

				} else if (y + dy > canvas.height - ballRadius) {

					if (x > paddleX && x < paddleX + paddleWidth) {
						dy = moveBallUpward(dy);

					} else {
						gameIsOver();

					}
				}
				/// End collision detection

				/**
				 * Move the paddle on the left or right side of the canvas based
				 * on whether the left or right buttons were pressed.
				 */
				if (rightPressed && paddleX < canvas.width - paddleWidth) {
					paddleX += 7;

				} else if (leftPressed && paddleX > 0) {
					paddleX -= 7;

				}

				// Update the score and high score
				scoreCounter();

				// 

				/**
				 * @function logDrawFn
				 *
				 * Logging function: used to output the position of the x and y position
				 * of the ball.
				 */
				function logDrawFn() {
					console.log('y is: ');
					console.log(y);
					console.log('x is: ');
					console.log(x);
				}			

				// @JC 23/12/18: 
				if(!stop) {
					animationFn();
				}
			}

			// @JC 23/12/18: Framerate controlled by the host environment
			var animationFn = function() {
				frames = requestAnimationFrame(draw);	
			};
			

			// @JC 23/12/18: stop the game loop / animation.
			var stopDrawing = function(stop) {
				if(stop) {
					cancelAnimationFrame(frames);
					// frames = undefined;
				}
			};

			// @JC 24/12/18: dispaly the level number in the UI
			var levelNumberUi = function() {
				debugger
				if(localStorage.getItem('level')) {
					document.querySelector('#currentLevel').textContent = localStorage.getItem('level');
				} else {
					document.querySelector('#currentLevel').textContent = 1
				}
				
			};

			/********************************************************/
			// # ENTER THE DRAW LOOP
			/********************************************************/
			
			// Commented out to use requestAnimationFrame()
			// var interval = setInterval(draw, 10);
			
			// Calls draw which runs requestAnimationFrame(draw);
			draw();
			// End enter the draw loop

			levelNumberUi();

			/********************************************************/
			// # EVENTS
			/********************************************************/

			/**
			 * Handle left and right movement of the paddle
			 */
			var keyDownHandler = function(e) {
				if (e.keyCode == 39) {
		
					rightPressed = true;

				} else if (e.keyCode == 37) {
				
					leftPressed = true;
				}
			};

			var keyUpHandler = function(e) {
				if (e.keyCode == 39) {
					rightPressed = false;

				} else if (e.keyCode == 37) {
					leftPressed = false;
				}

			};

			document.addEventListener("keydown", keyDownHandler, false);
			document.addEventListener("keyup", keyUpHandler, false);

			/**
			 * Handle restartig of the game
			 */
			var restartLevel = function(e) {
				if (e.target.id == 'restartLevel') {
					window.location.reload();
				}
			};

			document.addEventListener("click", restartLevel, false);

			/**
			 * @JC 23/12/18: increases the difficulty of the game for each level.
			 */
			var nextLevel = function(e) {
				if(e.target.id == 'nextLevel') {
					
					function getRandomIntInclusive(min, max) {
						var	min = Math.ceil(min);
						var	max = Math.floor(max);
						return Math.floor(Math.random() * (max - min + 1)) + min; //The maximum is inclusive and the minimum is inclusive 
					}

					// @JC 23/12/18: 
					levelNumber++;
					localStorage.setItem("level", levelNumber);
					
					localStorage.setItem("dx", getRandomIntInclusive(1, 3)+1);
					localStorage.setItem("dy", getRandomIntInclusive(5, 7)+1);

					//localStorage.setItem("score", score);
					
					window.location.reload();
				}
			};
			document.addEventListener("click", nextLevel, false);	
			
			// 23/12/18: reset game to level one
			var newGame = function(e) {
				if(e.target.id == 'newGame') {
					localStorage.setItem("dx", 3);
					localStorage.setItem("dy", -3);
					localStorage.setItem("level",1);
					window.location.reload();
				}				
			};
			document.addEventListener("click", newGame, false);

		}());
	</script>

</body>

</html>
